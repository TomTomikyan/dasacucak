import { useState, useCallback, useEffect } from 'react';
import { Institution, ClassGroup, Subject, Classroom, Teacher, ScheduleSlot } from '../types';

const getDefaultBreakDurations = (lessonsPerDay: number): number[] => {
  // College default: short breaks (5 min) and long breaks (20 min)
  return Array.from({ length: lessonsPerDay - 1 }, (_, i) => {
    // Long break after 2nd lesson
    return i === 1 ? 20 : 10;
  });
};

const defaultInstitution: Institution = {
  id: '1',
  name: '',
  type: 'college',
  workingDays: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],
  lessonsPerDay: 4,
  lessonDuration: 70,
  breakDurations: getDefaultBreakDurations(4),
  startTime: '09:00',
  academicWeeks: 40,
  specializations: [], // Initialize empty specializations array
};

// Local storage keys
const STORAGE_KEYS = {
  INSTITUTION: 'college_schedule_institution',
  CLASS_GROUPS: 'college_schedule_class_groups',
  SUBJECTS: 'college_schedule_subjects',
  CLASSROOMS: 'college_schedule_classrooms',
  TEACHERS: 'college_schedule_teachers',
  SCHEDULE: 'college_schedule_schedule',
};

// Helper functions for localStorage
const saveToStorage = (key: string, data: any) => {
  try {
    localStorage.setItem(key, JSON.stringify(data));
  } catch (error) {
    console.error('Error saving to localStorage:', error);
  }
};

const loadFromStorage = <T>(key: string, defaultValue: T): T => {
  try {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : defaultValue;
  } catch (error) {
    console.error('Error loading from localStorage:', error);
    return defaultValue;
  }
};

export const useScheduleData = () => {
  // Load initial data from localStorage
  const [institution, setInstitution] = useState<Institution>(() => 
    loadFromStorage(STORAGE_KEYS.INSTITUTION, defaultInstitution)
  );
  const [classGroups, setClassGroups] = useState<ClassGroup[]>(() => 
    loadFromStorage(STORAGE_KEYS.CLASS_GROUPS, [])
  );
  const [subjects, setSubjects] = useState<Subject[]>(() => 
    loadFromStorage(STORAGE_KEYS.SUBJECTS, [])
  );
  const [classrooms, setClassrooms] = useState<Classroom[]>(() => 
    loadFromStorage(STORAGE_KEYS.CLASSROOMS, [])
  );
  const [teachers, setTeachers] = useState<Teacher[]>(() => 
    loadFromStorage(STORAGE_KEYS.TEACHERS, [])
  );
  const [schedule, setSchedule] = useState<ScheduleSlot[]>(() => 
    loadFromStorage(STORAGE_KEYS.SCHEDULE, [])
  );

  // Auto-save to localStorage when data changes
  useEffect(() => {
    saveToStorage(STORAGE_KEYS.INSTITUTION, institution);
  }, [institution]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.CLASS_GROUPS, classGroups);
  }, [classGroups]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.SUBJECTS, subjects);
  }, [subjects]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.CLASSROOMS, classrooms);
  }, [classrooms]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.TEACHERS, teachers);
  }, [teachers]);

  useEffect(() => {
    saveToStorage(STORAGE_KEYS.SCHEDULE, schedule);
  }, [schedule]);

  // üî• –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —É—á–∏—Ç–µ–ª–µ–π –∫ –ø—Ä–µ–¥–º–µ—Ç–∞–º
  const autoAssignTeachersToSubjects = useCallback(() => {
    if (teachers.length === 0 || subjects.length === 0) return;

    let hasChanges = false;
    const updatedSubjects = subjects.map(subject => {
      // –ù–∞–π—Ç–∏ —É—á–∏—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–µ–ø–æ–¥–∞—é—Ç —ç—Ç–æ—Ç –ø—Ä–µ–¥–º–µ—Ç
      const matchingTeachers = teachers.filter(teacher => 
        teacher.subjects.includes(subject.name)
      );
      
      // –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–µ ID —É—á–∏—Ç–µ–ª–µ–π –¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–µ–¥–º–µ—Ç–∞
      const currentTeacherIds = subject.teacherIds || [];
      
      // –ü–æ–ª—É—á–∏—Ç—å ID –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —É—á–∏—Ç–µ–ª–µ–π
      const matchingTeacherIds = matchingTeachers.map(teacher => teacher.id);
      
      // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
      const shouldUpdate = 
        matchingTeacherIds.length !== currentTeacherIds.length ||
        !matchingTeacherIds.every(id => currentTeacherIds.includes(id)) ||
        !currentTeacherIds.every(id => teachers.some(t => t.id === id)); // üî• –ù–û–í–ê–Ø –ü–†–û–í–ï–†–ö–ê: —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –≤—Å–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–µ —É—á–∏—Ç–µ–ª—è –µ—â–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
      
      if (shouldUpdate) {
        hasChanges = true;
        return {
          ...subject,
          teacherIds: matchingTeacherIds
        };
      }
      
      return subject;
    });
    
    if (hasChanges) {
      setSubjects(updatedSubjects);
      console.log('üîÑ Auto-assigned teachers to subjects');
    }
  }, [teachers, subjects]);

  // üî• –ù–û–í–´–ô –≠–§–§–ï–ö–¢: –ó–∞–ø—É—Å–∫–∞—Ç—å –∞–≤—Ç–æ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —É—á–∏—Ç–µ–ª–µ–π –ò–õ–ò –ø—Ä–µ–¥–º–µ—Ç–æ–≤
  useEffect(() => {
    autoAssignTeachersToSubjects();
  }, [autoAssignTeachersToSubjects]);

  // üî• –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –û–ß–ò–°–¢–ö–ê: –£–¥–∞–ª–∏—Ç—å –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —É—á–∏—Ç–µ–ª–µ–π –∏–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
  useEffect(() => {
    if (schedule.length > 0 && teachers.length > 0) {
      const existingTeacherIds = new Set(teachers.map(t => t.id));
      const cleanedSchedule = schedule.filter(slot => existingTeacherIds.has(slot.teacherId));
      
      if (cleanedSchedule.length !== schedule.length) {
        console.log(`üßπ Cleaned ${schedule.length - cleanedSchedule.length} schedule slots with non-existent teachers`);
        setSchedule(cleanedSchedule);
      }
    }
  }, [teachers, schedule]);

  const updateInstitution = useCallback((updates: Partial<Institution>) => {
    setInstitution(prev => {
      const newInstitution = { ...prev, ...updates };
      
      // Update break durations when lessons per day changes
      if (updates.lessonsPerDay !== undefined) {
        const lessonsPerDay = updates.lessonsPerDay;
        newInstitution.breakDurations = getDefaultBreakDurations(lessonsPerDay);
      }
      
      return newInstitution;
    });
  }, []);

  const addClassGroup = useCallback((classGroup: Omit<ClassGroup, 'id'>) => {
    const newClassGroup: ClassGroup = {
      ...classGroup,
      id: Date.now().toString(),
      subjectHours: classGroup.subjectHours || {}, // Use provided subjectHours or empty object
    };
    setClassGroups(prev => [...prev, newClassGroup]);
  }, []);

  const updateClassGroupSubjects = useCallback((groupId: string, subjectHours: { [subjectId: string]: number }) => {
    setClassGroups(prev => prev.map(group => 
      group.id === groupId 
        ? { ...group, subjectHours }
        : group
    ));
  }, []);

  const addSubject = useCallback((subject: Omit<Subject, 'id'>) => {
    const newSubject: Subject = {
      ...subject,
      id: Date.now().toString(),
    };
    
    // üî• –ò–°–ü–†–ê–í–õ–ï–ù–û: –ê–≤—Ç–æ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —É—á–∏—Ç–µ–ª–µ–π –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
    const matchingTeachers = teachers.filter(teacher => 
      teacher.subjects.includes(subject.name)
    );
    newSubject.teacherIds = matchingTeachers.map(teacher => teacher.id);
    
    setSubjects(prev => [...prev, newSubject]);
  }, [teachers]);

  const addClassroom = useCallback((classroom: Omit<Classroom, 'id'>) => {
    const newClassroom: Classroom = {
      ...classroom,
      id: Date.now().toString(),
    };
    setClassrooms(prev => [...prev, newClassroom]);
  }, []);

  const addTeacher = useCallback((teacher: Omit<Teacher, 'id'>) => {
    const newTeacher: Teacher = {
      ...teacher,
      id: Date.now().toString(),
    };
    setTeachers(prev => [...prev, newTeacher]);
    // üî• –ê–≤—Ç–æ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ useEffect
  }, []);

  const generateClassrooms = useCallback((floors: number, roomsPerFloor: number) => {
    const newClassrooms: Classroom[] = [];
    
    for (let floor = 1; floor <= floors; floor++) {
      for (let room = 1; room <= roomsPerFloor; room++) {
        const roomNumber = `${floor}${room.toString().padStart(2, '0')}`;
        newClassrooms.push({
          id: `${floor}-${room}`,
          number: roomNumber,
          floor,
          type: 'theory',
          hasComputers: false,
          capacity: 30,
        });
      }
    }
    
    setClassrooms(newClassrooms);
  }, []);

  const generateCollegeGroups = useCallback((years: number[], specializations: string[]) => {
    const newGroups: ClassGroup[] = [];
    
    years.forEach(year => {
      specializations.forEach((spec, specIndex) => {
        for (let stream = 1; stream <= 3; stream++) {
          const groupName = `${year.toString().slice(-1)}${specIndex + 1}${stream}`;
          // Calculate course based on current year vs entry year
          const currentYear = new Date().getFullYear();
          const course = Math.min(Math.max(currentYear - year + 1, 1), 4);
          
          newGroups.push({
            id: `${year}-${specIndex}-${stream}`,
            name: groupName,
            type: 'college_group',
            course: course,
            specialization: spec,
            studentsCount: 25,
            subjectHours: {},
          });
        }
      });
    });
    
    setClassGroups(newGroups);
  }, []);

  // Export/Import functions
  const exportConfiguration = useCallback(() => {
    // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ö–†–û–ú–ï —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
    const configData = {
      institution,
      classGroups,
      subjects,
      classrooms,
      teachers,
      // schedule - –∏—Å–∫–ª—é—á–∞–µ–º –∏–∑ —ç–∫—Å–ø–æ—Ä—Ç–∞
      exportDate: new Date().toISOString(),
      version: '1.0'
    };

    const dataStr = JSON.stringify(configData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${institution.name || 'college'}_configuration_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [institution, classGroups, subjects, classrooms, teachers]); // —É–±—Ä–∞–ª–∏ schedule –∏–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π

  const importConfiguration = useCallback((file: File) => {
    return new Promise<void>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const configData = JSON.parse(e.target?.result as string);
          
          // Validate the structure
          if (!configData.institution || !configData.version) {
            throw new Error('Invalid configuration file format');
          }

          // Import data (–±–µ–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è)
          setInstitution(configData.institution);
          setClassGroups(configData.classGroups || []);
          setSubjects(configData.subjects || []);
          setClassrooms(configData.classrooms || []);
          setTeachers(configData.teachers || []);
          // setSchedule - –ù–ï –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ, –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ
          
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsText(file);
    });
  }, []);

  const clearAllData = useCallback(() => {
    setInstitution(defaultInstitution);
    setClassGroups([]);
    setSubjects([]);
    setClassrooms([]);
    setTeachers([]);
    setSchedule([]);
    
    // Clear localStorage
    Object.values(STORAGE_KEYS).forEach(key => {
      localStorage.removeItem(key);
    });
  }, []);

  return {
    institution,
    setInstitution: updateInstitution,
    classGroups,
    setClassGroups,
    addClassGroup,
    updateClassGroupSubjects,
    subjects,
    setSubjects,
    addSubject,
    classrooms,
    setClassrooms,
    addClassroom,
    generateClassrooms,
    teachers,
    setTeachers,
    addTeacher,
    schedule,
    setSchedule,
    generateCollegeGroups,
    exportConfiguration,
    importConfiguration,
    clearAllData,
  };
}